# -*- coding: utf-8 -*-
"""PureCalculus.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RM87rnBWlmBdw4x5HZZqLTo3Ua_3IVIw

# **Pure $\lambda$-Calculus**

[The deatailed script](https://www.mathcha.io/editor/Pvvz5UZ1t7ktL6sZJYp19sZnX9vVserJMEKhJvvMx7)

## **Variables**

The code below models variables.

Using the `natgen()` generator in this code ensures that a fresh variable is returned in response to each constructor call.
"""

def natgen():
    n = 0
    while True:
        yield n
        n += 1


class Var:
    __nats = natgen()

    def __init__(self):
        self._idx = next(Var.__nats)

    def __hash__(self):
        return self._idx.__hash__()

    def __str__(self):
        return "v[" + str(self._idx) + "]"

    def __eq__(self, other):
        return self._idx == other._idx

"""## **Terms**

"""

class Term:

    @property
    def isAtom(self):
        """checks whether the term is an atom"""
        return isinstance(self, Atom)

    @property
    def isApplication(self):
        """checks whether the term is an application"""
        return isinstance(self, Application)

    @property
    def isAbstraction(self):
        """checks whether the term is an abstraction"""
        return isinstance(self, Abstraction)

    def __str__(self):
        if self.isAtom:
            return str(self._var)
        if self.isApplication:
            return "(" + str(self._sub) + " " + str(self._obj) + ")"
        # self is Abbstraction
        return "(fun " + str(self._head) + " => " + str(self._body) + ")"

    def __eq__(self, other):
        if self.isAtom and other.isAtom:
            return self._var == other._var
        if isinstance(self, Application) and isinstance(other, Application):
            return self._sub == other._sub and self._obj == other._obj
        if isinstance(self, Abstraction) and isinstance(other, Abstraction):
            return self._head == other._head and self._body == other._body

    @property
    def isBetaRedex(self):
        """checks whether the term is a beta-redex"""
        return self.isApplication and self._sub.isAbstraction

    @property
    def redexes(self):
        """determiness all beta-redexes in the term"""
        if self.isAtom:
            return []
        if self.isAbstraction:
            return self._body.redexes
        # self is Application
        temp = [self ]if self.isBetaRedex else []
        temp += (self._sub.redexes + self._obj.redexes)
        return temp


    @property
    def _vars(self):
        """
        returns
        -------
            the dictionary stuctured as follows
                dict[Var, dict[['free' | 'bound'], int]]
            Here, keys of the external dictionary are the variables that
            are occurred in 'self', and values of the internal dictionaries
            relate respectively to the numbers of free and bound occurrences
            of the variables.
        """
        if self.isAtom:
            return {self._var: {'free': 1, 'bound': 0}}
        if self.isApplication:
            vars, auxvars = dict(self._sub._vars), self._obj._vars
            for var in auxvars:
                try:
                    for key in {'free', 'bound'}:
                       vars[var][key] += self._obj._vars[var][key]
                except KeyError:
                    vars[var] = dict(self._obj._vars[var])
            return vars
        # self is Abstraction
        vars = dict(self._body._vars)
        try:
            vars[self._head]['bound'] += vars[self._head]['free']
            vars[self._head]['free'] = 0
        except KeyError:
            pass
        return vars

    @property
    def verticesNumber(self):
      """return the number of nodes in the tree representing the lambda term"""
      if self.isAtom:
        return 1
      elif self.isApplication:
        return 1 + self._sub.verticesNumber + self._obj.verticesNumber
      else: # self is Abstraction
        return 1 + self._body.verticesNumber

    def normalize(self, strategy):
      """
      :param strategy: OneStepStrategy
      :return tuple of the normal form of the term and number of steps of betta reduction
      """
      term = self._updateBoundVariables()
      count = 0
      while term.redexes != []:
        term = term._betaConversion(strategy)
        count += 1
        if term.verticesNumber > 7000 or count > 400:
          return (self, float('inf'))
      return (term, count)

    def _betaConversion(self, strategy):
      """
      :param strategy: OneStepStrategy
      :return term with redex eliminated using the given strategy
      """
      index = strategy.redexIndex(self)
      subterm = self.subterm(index)
      reducedTerm = subterm._removeOuterRedex()
      return self.setSubterm(index, reducedTerm)

    def subterm(self, index: int):
      """
      By representing the term as a tree, a subtree is returned, which is also a lambda term.
      The vertex of this subtree has a given index in the topological sorting of the vertices of the original term.
      :param index - subterm index
      :return: subterm: Term
      """
      if index == 1:
        return self

      if self.isAtom:
        ValueError('index value is incorrect')
      elif self.isApplication:
        if self._sub.verticesNumber + 1 >= index:
          return self._sub.subterm(index - 1)
        else:
          return self._obj.subterm(index - self._sub.verticesNumber - 1)
      else: # self is Abstraction
        return self._body.subterm(index - 1)

    def setSubterm(self, index: int, term):
      """
      By representing the term as a tree, a subtree is set, which is also a lambda term.
      The vertex of this subtree has a given index in the topological sorting of the vertices of the original term.
      :param index - subterm index
      :param term - λ-term to which the subterm will be replaced
      :return: updated λ-term
      """
      if index == 1:
        return term

      if self.isAtom:
        ValueError('index value is incorrect')
      elif self.isApplication:
        if self._sub.verticesNumber + 1 >= index:
          return Application(self._sub.setSubterm(index - 1, term), self._obj)
        else:
          return Application(self._sub, self._obj.setSubterm(index - self._sub.verticesNumber - 1, term))
      else: # self is Abstraction
        return Abstraction(self._head, self._body.setSubterm(index - 1, term))

    def _updateBoundVariables(self):
      """return λ-term with updated bound variables"""
      if self.isAtom:
        return self
      elif self.isApplication:
        return Application(self._sub._updateBoundVariables(), self._obj._updateBoundVariables())
      else: # self is Abstraction
        newVar = Var()
        return Abstraction(newVar, self._body._replaceVariable(self._head, Atom(newVar))._updateBoundVariables())

    def _removeOuterRedex(self):
      """apply the betta conversion to the lambda term, removing the outer betta redex"""
      if self.isBetaRedex:
        head = self._sub._head
        body = self._sub._body
        return body._replaceVariable(head, self._obj)
      else:
        return self

    def _replaceVariable(self, var: Var, term):
      """return λ-term with replaced variable"""
      if self.isAtom:
        return term if self._var == var else self
      elif self.isApplication:
        return Application(self._sub._replaceVariable(var, term), self._obj._replaceVariable(var, term))
      else: # self is Abstraction
        return Abstraction(self._head, self._body._replaceVariable(var, term))


class Atom(Term):
    def __init__(self, x: Var):
        if isinstance(x, Var):
            self._var = x
        else:
            raise TypeError("a variable is waiting")


class Application(Term):
    def __init__(self, X : Term, Y : Term):
        if isinstance(X, Term) and isinstance(Y, Term):
            self._sub = X
            self._obj = Y
        else:
            raise TypeError("a term is waiting")


class Abstraction(Term):
    def __init__(self, x: Var, X: Term):
        if isinstance(x, Var):
            if isinstance(X, Term):
                self._head = x
                self._body = X
            else:
                raise TypeError("a term is waiting")
        else:
            raise TypeError("a variable is waiting")

"""## Strategy

"""

import random
from abc import ABC, abstractmethod

class OneStepStrategy(ABC):
    
  @abstractmethod
  def redexIndex(self, term: Term, initIndex = 0) -> int:
      """
      :return: index of the vertex of a subterm that has an outer redex. 
              The index of a vertex is the index of this vertex in the topological sort of the tree vertices.
              Indexing starts at 1.
      """

class LeftmostOutermostStrategy(OneStepStrategy):

  def redexIndex(self, term: Term, initIndex = 0) -> int:
    if term.isAtom or len(term.redexes) == 0:
      ValueError('the term does not contain a redex')
    elif term.isApplication:
      if term.isBetaRedex:
        return initIndex + 1
      elif len(term._sub.redexes) != 0:
        return self.redexIndex(term._sub, initIndex + 1)
      else:
        return self.redexIndex(term._obj, initIndex + term._sub.verticesNumber + 1)
    else: # self is Abstraction
      return self.redexIndex(term._body, initIndex + 1)

class RightmostInnermostStrategy(OneStepStrategy):

  def redexIndex(self, term: Term, initIndex = 0) -> int:
    if term.isAtom or len(term.redexes) == 0:
      ValueError('the term does not contain a redex')
    elif term.isApplication:
      if len(term._obj.redexes) != 0:
        return self.redexIndex(term._obj, initIndex + term._sub.verticesNumber + 1)
      elif len(term._sub.redexes) != 0:
        return self.redexIndex(term._sub, initIndex + 1)
      else:
        return initIndex + 1
    else: # self is Abstraction
      return self.redexIndex(term._body, initIndex + 1)

class RandomStrategy(OneStepStrategy):

  def redexIndex(self, term: Term, initIndex = 0) -> int:
    redexes = term.redexes
    if term.isAtom or len(redexes) == 0:
      ValueError('the term does not contain a redex')
    elif term.isApplication:
      index = random.randint(0, len(redexes) - 1)
      if term.isBetaRedex and index == 0:
        return initIndex + 1
      elif len(term._sub.redexes) >= index and len(term._sub.redexes) != 0:
        return self.redexIndex(term._sub, initIndex + 1)
      else:
        return self.redexIndex(term._obj, initIndex + term._sub.verticesNumber + 1)
    else: # self is Abstraction
      return self.redexIndex(term._body, initIndex + 1)

"""## Generating lambda terms"""

import random
from typing import List
import sys

sys.setrecursionlimit(40000)

def genTerm(p: float, uplimit: int, vars: List[Var] = []):

  if uplimit < 1:
    return None

  pVar = (1 - p * p) / 2
  pAbs = pVar + p * p

  rand = random.random()

  if rand < pVar and len(vars) > 0:
    index = random.randint(0, len(vars) - 1)
    return Atom(vars[index]) 
  elif rand < pAbs:
    head = Var()
    body = genTerm(p, uplimit - 1, vars + [head])
    return Abstraction(head, body) if body else None
  else:
    sub = genTerm(p, uplimit - 1, vars)
    obj = genTerm(p, uplimit - 1, vars)
    if sub and obj and sub.verticesNumber + obj.verticesNumber <= uplimit:
      return Application(sub, obj)
    else:
      return None

import numpy as np

UPLIMIT = 80
DOWNLIMIT = 60

RANDOM_COUNT = 100

def filterTerms(term):
  return term and DOWNLIMIT < term.verticesNumber < UPLIMIT

def flatten(t):
    return [item for sublist in t for item in sublist]

terms = flatten([list(filter(filterTerms, [genTerm(p, UPLIMIT) for i in range(800)])) for p in np.arange(0.37, 0.44, 0.01)])

countVertices = list(map(lambda term: term.verticesNumber, terms))
countRedexes = list(map(lambda term: len(term.redexes), terms))

print("number of vertices= {}".format(countVertices))
print("number of redexes= {}".format(countRedexes))

stepsLO = list(map(lambda term: term.normalize(LeftmostOutermostStrategy())[1], terms))
print("number of steps to normalize using LO strategy= {}".format(stepsLO))

stepsRI = [term.normalize(RightmostInnermostStrategy())[1] if stepsLO[i] != float('inf') else float('inf') for i, term in enumerate(terms)]
print("number of steps to normalize using RI strategy= {}".format(stepsRI))

stepsRand = [sum([term.normalize(RandomStrategy())[1] for i in range(RANDOM_COUNT)]) / RANDOM_COUNT if stepsLO[i] != float('inf') else float('inf') for i, term in enumerate(terms)]
print("number of steps to normalize using Random strategy= {}".format(stepsRand))

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d

def draw_2d_distribution(ax, x, y, xlabel, ylabel):
    ax.scatter(x, y, color='blue')
    ax.set(title = 'Distribution of ' + xlabel.lower() + '-' + ylabel.lower(),
           xlabel = xlabel,
           ylabel = ylabel)
    ax.legend(prop={'size': 10})

def draw_2d_strategy_distribution(ax, x, y, xlabel, ylabel):
    x = list(map(lambda v: -1 if v == float('inf') else v, x))
    y = list(map(lambda v: -1 if v == float('inf') else v, y))
    greater = list(zip(*list(filter(lambda z: z[0] >= z[1] and z[0] != -1 and z[1] != -1, zip(x, y)))))
    less = list(zip(*list(filter(lambda z: z[0] < z[1] and z[0] != -1 and z[1] != -1, zip(x, y)))))
    inf_x  = list(zip(*list(filter(lambda z: z[0] == -1 and z[1] != -1, zip(x, y)))))
    inf_y  = list(zip(*list(filter(lambda z: z[0] != -1 and z[1] == -1, zip(x, y)))))
    inf_xy  = list(zip(*list(filter(lambda z: z[0] == -1 and z[1] == -1, zip(x, y)))))
    ax.scatter(greater[0], greater[1], color='blue', label='{} <= {}'.format(ylabel, xlabel))
    ax.scatter(less[0], less[1], color='red', label='{} < {}'.format(xlabel, ylabel))
    if inf_x:
      ax.scatter(inf_x[0], inf_x[1], color='lime', label="{} doesn't normalize".format(xlabel))
    if inf_y:  
      ax.scatter(inf_y[0], inf_y[1], color='yellow', label="{} dooesn't normalize".format(ylabel))
    if inf_xy:
      ax.scatter(inf_xy[0], inf_xy[1], color='orange', label="Both strategies don't normalize")
    ax.set(title = 'Distribution of ' + xlabel.lower() + '-' + ylabel.lower(),
           xlabel = xlabel,
           ylabel = ylabel)
    ax.legend(prop={'size': 10})

figure, axes = plt.subplots(nrows=2, ncols=2, figsize=(20,15))
ax0, ax1, ax2, ax3 = axes.flatten()
draw_2d_distribution(ax0, countVertices, countRedexes, 'Vertices number', 'Redexes number')
draw_2d_strategy_distribution(ax1, stepsLO, stepsRI, 'Leftmost outermost strategy', 'Rightmost inermost strategy')
draw_2d_strategy_distribution(ax2, stepsLO, stepsRand, 'Leftmost outermost strategy', 'Random strategy')
draw_2d_strategy_distribution(ax3, stepsRI, stepsRand, 'Rightmost inermost strategy', 'Random strategy')
plt.show()

import pandas as pd

def draw_plot(x, y, z, labels, colors):
  x = list(map(lambda v: -5 if v == float('inf') else v, x))
  y = list(map(lambda v: -5 if v == float('inf') else v, y))
  z = list(map(lambda v: -5 if v == float('inf') else v, z))

  data = pd.DataFrame(zip(x, y, z), columns = labels)
  ax0 = data.plot(figsize=(20,10), kind='bar', color=colors)
  ax0.set(title = 'Distribution of number of reduction steps for each term',
          xlabel = 'Term index',
          ylabel = 'Number of reduction steps')
  ax0.legend(prop={'size': 10})
  return ax0

colors = ['lime', 'blue', 'red']
labels = ['Leftmost outermost', 'Rightmost inermost', 'Random']
draw_plot(stepsLO, stepsRI, stepsRand, labels, colors)

terms_dict = {i: [] for i in range(DOWNLIMIT, UPLIMIT)}

for i, term in enumerate(terms):
  terms_dict[term.verticesNumber].append((term, {'LO': stepsLO[i], 'RI': stepsRI[i], 'Rand': stepsRand[i]}))

average_term_data = dict()
for verticesNumber, data in terms_dict.items():
  data_without_inf = [d[1] for d in data if d[1]['LO'] != float('inf') and d[1]['RI'] != float('inf') and d[1]['Rand'] != float('inf')]
  avgLO, avgRI, avgRand = 0, 0, 0
  for d in data_without_inf:
    avgLO += d['LO']
    avgRI += d['RI']
    avgRand += d['Rand']
     
  count = len(data_without_inf)
  if count != 0:
    average_term_data[verticesNumber] = {'LO': avgLO / count, 'RI': avgRI / count, 'Rand': avgRand / count}

plt.figure(figsize=(20, 15))
ax = plt.gca()
ax.plot(list(average_term_data.keys()), [data['LO'] for i, data in average_term_data.items()], color='blue', label='LO')
ax.plot(list(average_term_data.keys()), [data['RI'] for i, data in average_term_data.items()], color='lime', label='RI')
ax.plot(list(average_term_data.keys()), [data['Rand'] for i, data in average_term_data.items()], color='red', label='Rand')
ax.set(title = 'Distribution',
        xlabel = 'Vertices number',
        ylabel = 'Strategy steps number')
ax.legend(prop={'size': 10})

plt.show()

"""## Tests"""

x, y, z = Var(), Var(), Var()
X, Z = Atom(x), Atom(z)
XXX = Application(Application(X, X), X)
XZ = Application(X, Z)
T = Application(Abstraction(x, XXX),
                Abstraction(x, Application(Abstraction(y, Z),
                                           XZ
                                          ))
               )

print(T)
for var, item in T._vars.items():
    print("\t{}".format(var), end=": ")
    print(item)

x, y, z, w, v = Var(), Var(), Var(), Var(), Var()
# (λx.(λy.( ((λz.(y z)) ((λw.w) x)) v )))
lambdaTerm = Abstraction(x,
                        Abstraction(y,
                                    Application(
                                        Application(
                                            Abstraction(z, Application(Atom(y), Atom(z))),
                                            Application(Abstraction(w, Atom(w)), Atom(w))),
                                        Atom(v))))

def testTerm():
  assert(len(lambdaTerm.redexes) == 2)
  assert(lambdaTerm.verticesNumber == 13)

  subterm = Application(Atom(y), Atom(z))
  assert(lambdaTerm.subterm(1) == lambdaTerm)
  assert(lambdaTerm.subterm(6) == subterm)
  assert(lambdaTerm.setSubterm(1, subterm) == subterm)

  assert(lambdaTerm._updateBoundVariables().verticesNumber == lambdaTerm.verticesNumber)
  assert(len(lambdaTerm._updateBoundVariables().redexes) == len(lambdaTerm.redexes))

  strategy = LeftmostOutermostStrategy()
  assert(len(lambdaTerm._betaConversion(strategy).redexes) == 1)
  assert(lambdaTerm._betaConversion(strategy).verticesNumber == 10)

  assert(len(lambdaTerm.normalize(strategy)[0].redexes) == 0)
  assert(lambdaTerm.normalize(strategy)[1] == 2)


def testStrategy():
  strategy = LeftmostOutermostStrategy()
  assert(strategy.redexIndex(lambdaTerm) == 4)

testTerm()
testStrategy()